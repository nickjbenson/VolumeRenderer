// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CreateParticle

int _particleTexWidth = 1024;
RWTexture2D<float4> _createParticleTex;
[numthreads(32, 32, 1)]
void CreateParticle(uint3 pixel : SV_DispatchThreadID) {
	float texWidth = (float)_particleTexWidth;
	float x = pixel.x - texWidth / 2.0;
	float y = pixel.y - texWidth / 2.0;
	float light = 1 - ((x * x + y * y) / (texWidth * texWidth / 5.0));
	_createParticleTex[pixel.xy] = float4(1.0, 0.0, 1.0, 1.0);
}

#pragma kernel PaintParticles
#pragma kernel ClearParticles

int _paintedParticleTexWidth = 1024;
RWTexture2D<float4> _particleTex;
Texture2D<float4> _particleSourceTex;
RWTexture2D<float4> _paintedParticleTex;

[numthreads(32, 32, 1)]
void PaintParticles(uint3 pixel : SV_DispatchThreadID) {
	uint particleStep = 16;
	float particleSize = (1.0 / particleStep);
	
	float rChannel = _particleSourceTex[pixel.xy].x;
	if (rChannel < 0.01) {
		return;
  }

	int effParticleWidth = (int)(_particleTexWidth * particleSize);
	int particleXYOffset = effParticleWidth;
	for (int i = 0; i < effParticleWidth; i++) {
		uint paintedX = pixel.x - particleXYOffset + i;
		for (int j = 0; j < effParticleWidth; j++) {
			uint paintedY = pixel.y - particleXYOffset + j;
			uint2 paintedPos = uint2(paintedX, paintedY);
			uint2 particleTexPos = uint2(i * particleStep, j * particleStep);
			_paintedParticleTex[paintedPos] = (_particleTex[particleTexPos] * rChannel) + _paintedParticleTex[paintedPos];
		}
	}

}

[numthreads(32, 32, 1)]
void ClearParticles(uint3 pixel : SV_DispatchThreadID) {
	_paintedParticleTex[pixel.xy] = float4(0, 0, 0, 0);
}